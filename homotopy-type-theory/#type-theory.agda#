{-# OPTIONS --without-K --safe --cubical #-}

module type-theory where

open import Agda.Primitive renaming (Set to Type)
open import Data.Empty
open import Data.Unit
open import Data.Sum
open import Data.Nat
open import Data.Bool
open import Relation.Nullary using (Â¬_)
open import Data.Product
open import Function using (_âˆ˜_; const; id; _|>_)
open import Agda.Builtin.Sigma
open import Cubical.Foundations.Prelude

-- Exercise 1.1. Given functions f : A â†’ B and g : B â†’ C, define their composite g â—¦ f : A â†’ C. Show that we have h â—¦ (g â—¦ f) â‰¡ (h â—¦ g) â—¦ f.
_âˆ˜'_ : {â„“ : Level} {A B C : Type â„“} -> (B -> C) -> (A -> B) -> A -> C
_âˆ˜'_ g f = Î» a -> g (f a)

âˆ˜'-assoc : {â„“ : Level} {A B C D : Type â„“} -> {h : C -> D} -> {g : B -> C} -> {f : A -> B} -> h âˆ˜' (g âˆ˜' f) â‰¡ (h âˆ˜' g) âˆ˜' f
âˆ˜'-assoc {h = h} {g = g} {f = f} = refl

-- Exercise 1.2. Derive the recursion principle for products recAÃ—B using only the projections, and verify that the definitional equalities are valid. Do the same for Î£-types.
Ã—-rec : {â„“ : Level} {A B C : Type â„“} -> (A -> B -> C) -> (A Ã— B) -> C
Ã—-rec f = Î» p -> f (projâ‚ p) (projâ‚‚ p)

Î£-rec : {â„“ : Level} {A : Type â„“} {B : A -> Type â„“} {C : Type â„“} -> ((a : A) -> (b : B a) -> C) -> Î£ A B -> C
Î£-rec f = Î» p -> f (fst p) (snd p)

-- Exercise 1.3. Derive the induction principle for products indAÃ—B, using only the projections and the propositional uniqueness principle uniqAÃ—B. Verify that the definitional equalities are valid.
Ã—-ind : {â„“ : Level} {A B : Type â„“} {C : A Ã— B -> Type â„“} -> ((a : A) -> (b : B) -> C (a , b)) -> (p : A Ã— B) -> C p
Ã—-ind f = Î» p -> f (projâ‚ p) (projâ‚‚ p)

Î£-ind : {â„“ : Level} {A : Type â„“} {B : A -> Type â„“} {C : Î£ A B -> Type â„“} -> ((a : A) -> (b : B a) -> C (a , b)) -> (p : Î£ A B) -> C p
Î£-ind f = Î» p -> f (fst p) (snd p)

-- Exercise 1.4. Assuming as given only the iterator for natural numbers iter : âˆ C:U C â†’ (C â†’ C) â†’ N â†’ C with the defining equations iter(C, c0, cs, 0) :â‰¡ c0, iter(C, c0, cs, succ(n)) :â‰¡ cs(iter(C, c0, cs, n)), derive a function having the type of the recursor recN. Show that the defining equations of the recursor hold propositionally for this function, using the induction principle for N.
iter : {â„“ : Level} {C : Type â„“} -> C -> (C -> C) -> â„• -> C
iter câ‚€ câ‚› zero = câ‚€
iter câ‚€ câ‚› (suc n) = câ‚› (iter câ‚€ câ‚› n)

step : {â„“ : Level} {C : Type â„“} -> (â„• -> C -> C) -> â„• Ã— C â†’ â„• Ã— C
step f (n , c) = (suc n , f n c)

â„•-rec : {â„“ : Level} {C : Type â„“} -> C -> (â„• -> C -> C) -> â„• -> C
â„•-rec câ‚€ câ‚› = projâ‚‚ âˆ˜ iter (zero , câ‚€) (step câ‚›)

zero-â„•-rec : {â„“ : Level} {C : Type â„“} {câ‚€ : C} {câ‚› : â„• -> C -> C} -> â„•-rec câ‚€ câ‚› zero â‰¡ câ‚€
zero-â„•-rec = refl

suc-â„•-rec : {â„“ : Level} {C : Type â„“} {câ‚€ : C} {câ‚› : â„• -> C -> C} {n : â„•} -> â„•-rec câ‚€ câ‚› (suc n) â‰¡ câ‚› n (â„•-rec câ‚€ câ‚› n)
suc-â„•-rec {câ‚€ = câ‚€} {câ‚› = câ‚›} {n = n} = cong (Î» m -> câ‚› m (â„•-rec câ‚€ câ‚› n)) (lemma n)
  where lemma : (n : â„•) -> projâ‚ (iter (zero , câ‚€) (step câ‚›) n) â‰¡ n
        lemma zero    = refl
        lemma (suc n) = cong suc (lemma n)

-- Exercise 1.5. Show that if we define A + B :â‰¡ âˆ‘(x:2) rec2(U , A, B, x), then we can give a definition of indA+B for which the definitional equalities stated in Â§1.7 hold.
Bool-rec : {â„“ : Level} {C : Type â„“} -> C -> C -> Bool -> C
Bool-rec câ‚€ câ‚ false = câ‚€
Bool-rec câ‚€ câ‚ true = câ‚

_+'_ : {â„“ : Level} (A B : Type â„“) -> Type â„“
_+'_ A B = Î£ Bool (Bool-rec A B)

+'-ind : {â„“ : Level} {A B : Type â„“} {C : A +' B -> Type â„“} -> ((a : A) -> C (false , a)) -> ((b : B) -> C (true , b)) -> (p : A +' B) -> C p
+'-ind câ‚€ câ‚ (false , a) = câ‚€ a
+'-ind câ‚€ câ‚ (true , b) = câ‚ b

inl-+'-ind : {â„“ : Level} {A B : Type â„“} {C : A +' B -> Type â„“} {fâ‚€ : (a : A) -> C (false , a)} {fâ‚ : (b : B) -> C (true , b)} {a : A} -> +'-ind {C = C} fâ‚€ fâ‚ (false , a) â‰¡ fâ‚€ a
inl-+'-ind = refl

inr-+'-ind : {â„“ : Level} {A B : Type â„“} {C : A +' B -> Type â„“} {fâ‚€ : (a : A) -> C (false , a)} {fâ‚ : (b : B) -> C (true , b)} {b : B} -> +'-ind {C = C} fâ‚€ fâ‚ (true , b) â‰¡ fâ‚ b
inr-+'-ind = refl

-- Exercise 1.8. Define multiplication and exponentiation using recN. Verify that (N, +, 0, Ã—, 1) is a semiring using only indN. You will probably also need to use symmetry and transitivity of equality, Lemmas 2.1.1 and 2.1.2.
record Semiring {â„“ : Level} : Type (â„“-suc â„“) where
  infix 6 _ï¼‹_
  infix 7 _ï¼Š_
  field 
    ð“¡ : Type â„“
    _ï¼‹_ : ð“¡ -> ð“¡ -> ð“¡
    0ð“¡ : ð“¡
    _ï¼Š_ : ð“¡ -> ð“¡ -> ð“¡
    1ð“¡ : ð“¡
    ï¼‹-unitâ‚— : (a : ð“¡) -> (0ð“¡ ï¼‹ a) â‰¡ a
    ï¼‹-unitáµ£ : (a : ð“¡) -> a ï¼‹ 0ð“¡ â‰¡ a
    ï¼‹-assoc : (a b c : ð“¡) -> a ï¼‹ (b ï¼‹ c) â‰¡ (a ï¼‹ b) ï¼‹ c
    ï¼Š-unitâ‚— : (a : ð“¡) -> (1ð“¡ ï¼Š a) â‰¡ a
    ï¼Š-unitáµ£ : (a : ð“¡) -> (a ï¼Š 1ð“¡) â‰¡ a
    ï¼Š-assoc : (a b c : ð“¡) -> a ï¼Š (b ï¼Š c) â‰¡ (a ï¼Š b) ï¼Š c
    ï¼Š-distrâ‚— : (a b c : ð“¡) -> a ï¼Š (b ï¼‹ c) â‰¡ a ï¼Š b ï¼‹ a ï¼Š c
    ï¼Š-distráµ£ : (a b c : ð“¡) -> (b ï¼‹ c) ï¼Š a â‰¡ b ï¼Š a ï¼‹ c ï¼Š a
open Semiring public

â„•'-rec : {â„“ : Level} {C : Type â„“} -> C -> (â„• -> C -> C) -> â„• -> C
â„•'-rec câ‚€ câ‚› zero    = câ‚€
â„•'-rec câ‚€ câ‚› (suc n) = câ‚› n (â„•'-rec câ‚€ câ‚› n)

infixl 6 _+â„•_
_+â„•_ : â„• -> â„• -> â„•
n +â„• m = â„•'-rec m (Î» _ n' -> suc n') n

infixl 7 _Ã—â„•_
_Ã—â„•_ : â„• -> â„• -> â„•
n Ã—â„• m = â„•'-rec zero (Î» _ n' -> m +â„• n') n

infixl 8 _^â„•_
_^â„•_ : â„• -> â„• -> â„•
n ^â„• m = â„•'-rec 1 (Î» _ n' -> n Ã—â„• n') m

â„•SemiRing : Semiring
â„•SemiRing = record
  { ð“¡ = â„•
  ; _ï¼‹_ = _+â„•_
  ; 0ð“¡ = zero
  ; _ï¼Š_ = _Ã—â„•_
  ; 1ð“¡ = suc zero
  ; ï¼‹-unitâ‚— = Î» _ -> refl
  ; ï¼‹-unitáµ£ = +-unitáµ£
  ; ï¼‹-assoc = +-assoc
  ; ï¼Š-unitâ‚— = Ã—-unitâ‚—
  ; ï¼Š-unitáµ£ = Ã—-unitáµ£
  ; ï¼Š-assoc = Ã—-assoc
  ; ï¼Š-distrâ‚— = Ã—-distrâ‚—
  ; ï¼Š-distráµ£ = Ã—-distráµ£
  }
  where
    +-unitáµ£ : (n : â„•) â†’ (n +â„• 0) â‰¡ n
    +-unitáµ£ zero = refl
    +-unitáµ£ (suc n) = cong suc (+-unitáµ£ n)

    +-assoc : (n m Ã± : â„•) â†’ n +â„• (m +â„• Ã±) â‰¡ (n +â„• m) +â„• Ã±
    +-assoc zero zero Ã± = refl
    +-assoc zero (suc m) Ã± = cong suc (+-assoc zero m Ã±)
    +-assoc (suc n) m Ã± = cong suc (+-assoc n m Ã±)

    +-suc : (m n : â„•) â†’ m +â„• suc n â‰¡ suc (m +â„• n)
    +-suc zero n = refl
    +-suc (suc m) n = cong suc (+-suc m n)

    +-comm : (n m : â„•) â†’ n +â„• m â‰¡ m +â„• n
    +-comm zero m = sym (+-unitáµ£ m)
    +-comm (suc n) m = cong suc (+-comm n m) âˆ™ sym (+-suc m n)

    Ã—-unitâ‚— : (n : â„•) â†’ 1 Ã—â„• n â‰¡ n
    Ã—-unitâ‚— zero = refl
    Ã—-unitâ‚— (suc n) = cong suc (Ã—-unitâ‚— n)

    Ã—-unitáµ£ : (n : â„•) â†’ n Ã—â„• 1 â‰¡ n
    Ã—-unitáµ£ zero = refl
    Ã—-unitáµ£ (suc n) = cong suc (Ã—-unitáµ£ n)

    Ã—-distrâ‚— : (n m Ã± : â„•) â†’ n Ã—â„• (m +â„• Ã±) â‰¡ n Ã—â„• m +â„• n Ã—â„• Ã±
    Ã—-distrâ‚— zero m Ã± = refl
    Ã—-distrâ‚— (suc n) m Ã± =
        cong ((m +â„• Ã±) +â„•_) (Ã—-distrâ‚— n m Ã±)
        âˆ™ +-assoc (m +â„• Ã±) (n Ã—â„• m) (n Ã—â„• Ã±)
        âˆ™ cong (_+â„• n Ã—â„• Ã±) (sym (+-assoc m Ã± (n Ã—â„• m)))
        âˆ™ cong (Î» x â†’ (m +â„• x) +â„• n Ã—â„• Ã±) (+-comm Ã± (n Ã—â„• m))
        âˆ™ cong (_+â„• n Ã—â„• Ã±) (+-assoc m (n Ã—â„• m) Ã±)
        âˆ™ sym (+-assoc (m +â„• n Ã—â„• m) Ã± (n Ã—â„• Ã±))

    Ã—-distráµ£ : (n m Ã± : â„•) â†’ (m +â„• Ã±) Ã—â„• n â‰¡ m Ã—â„• n +â„• Ã± Ã—â„• n
    Ã—-distráµ£ n zero Ã± = refl
    Ã—-distráµ£ n (suc m) Ã± =
        cong (n +â„•_) (Ã—-distráµ£ n m Ã±) âˆ™ +-assoc n (m Ã—â„• n) (Ã± Ã—â„• n)

    suc-distr : (n m : â„•) â†’ suc n Ã—â„• m â‰¡ m +â„• n Ã—â„• m
    suc-distr n m = refl

    Ã—-assoc : (n m Ã± : â„•) â†’ n Ã—â„• (m Ã—â„• Ã±) â‰¡ (n Ã—â„• m) Ã—â„• Ã±
    Ã—-assoc zero m Ã± = refl
    Ã—-assoc (suc n) m Ã± =
        suc-distr n (m Ã—â„• Ã±)
        âˆ™ cong ((m Ã—â„• Ã±) +â„•_) (Ã—-assoc n m Ã±)
        âˆ™ sym (Ã—-distráµ£ Ã± m (n Ã—â„• m))

-- Exercise 1.9. Define the type family Fin : N â†’ U mentioned at the end of Â§1.3, and the dependent function fmax : âˆ(n:N) Fin(n + 1) mentioned in Â§1.4.
Fin : â„• -> Type
Fin zero    = âŠ¥
Fin (suc n) = âŠ¤ âŠŽ Fin n

fmax : (n : â„•) -> Fin (suc n)
fmax n = injâ‚ tt

-- Exercise 1.10. Show that the Ackermann function ack : N â†’ N â†’ N is definable using only recN satisfying the following equations: ack(0, n) â‰¡ succ(n), ack(succ(m), 0) â‰¡ ack(m, 1), ack(succ(m), succ(n)) â‰¡ ack(m, ack(succ(m), n)).
ack : â„• -> â„• -> â„•
ack = â„•-rec suc (Î» pm rm -> â„•-rec (rm 1) (Î» pn rn -> rm rn))

-- Exercise 1.11. Show that for any type A, we have Â¬Â¬Â¬A â†’ Â¬A
doubleNeg : {â„“ : Level} {A : Type â„“} -> Â¬ Â¬ Â¬ A -> Â¬ A
doubleNeg nnnA = Î» A -> nnnA (Î» nA -> nA A)

-- Exercise 1.12. Using the propositions as types interpretation, derive the following tautologies. (i) If A, then (if B then A). (ii) If A, then not (not A). (iii) If (not A or not B), then not (A and B).
tau1 : {â„“ : Level} {A B : Type â„“} -> A -> (B -> A)
tau1 = Î» a -> Î» _ -> a -- which is const

tau2 : {â„“ : Level} {A : Type â„“} -> A -> Â¬ Â¬ A
tau2 A = Î» nA -> nA A -- which is application

tau3 : {â„“ : Level} {A B : Type â„“} -> (Â¬ A âŠŽ Â¬ B) -> Â¬ (A Ã— B)
tau3 (injâ‚ na) = Î» (a , b) -> na a -- which is case-split
tau3 (injâ‚‚ nb) = Î» (a , b) -> nb b

-- Exercise 1.13. using propositions-as-types, derive the double negation of the principle of ex- cluded middle, i.e. prove not (not (p or not p))
Â¬Â¬LEM : {â„“ : Level} {P : Type â„“} -> Â¬ Â¬ (P âŠŽ Â¬ P)
Â¬Â¬LEM = Î» Â¬LEM -> uncurry _|>_ (deMorgan Â¬LEM)
  where deMorgan : {â„“ : Level} {A B : Type â„“} -> Â¬ (A âŠŽ B) -> Â¬ A Ã— Â¬ B
        deMorgan nAorB = (Î» a -> nAorB (injâ‚ a)) , (Î» b -> nAorB (injâ‚‚ b))
