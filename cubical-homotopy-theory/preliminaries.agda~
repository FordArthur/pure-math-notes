{-# OPTIONS --without-K --safe --cubical #-}

-- NOTE: I somewhat tried to follow the structure of the Cubical Homotopy Theory book, however, their proofs and definitions
-- do not have synthetic homotopy theory in mind and so I am also getting ideas from the HoTT book.

-- Also, this module contains more than the first chapter from the CHT book, it also contains implicit assumptions to be used
-- throught the book

module preliminaries where

open import Data.Unit
open import Data.Bool
open import Data.Nat
open import Function
open import Function.Base
open import Agda.Primitive renaming (Set to Type)
open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Isomorphism

-- Definition (Functoriality)
record Functor {ℓ} (F : Type ℓ -> Type ℓ) : Type (lsuc ℓ) where
  field
    fmap : {X Y : Type ℓ} -> (X -> Y) -> F X -> F Y
    funIdn : {X : Type ℓ} -> fmap {X} id ≡ id
    funComp : {X Y Z : Type ℓ} {f : X -> Y} {g : Y -> Z} -> fmap (g ∘ f) ≡ fmap g ∘ fmap f

-- Theorem (Mapping space out of the point is equivalent to the codomain)
typeToposIsWellPointed : {ℓ : Level} { X : Type ℓ } -> (⊤ -> X) ≡ X
typeToposIsWellPointed = isoToPath (iso (λ f -> f tt) (λ x -> λ _ -> x) (λ x -> refl) (λ f -> refl))

-- Definition (Interval space)
data 𝕀 : Type where
  𝕚0 : 𝕀
  𝕚1 : 𝕀
  seg : Path 𝕀 𝕚0 𝕚1
open 𝕀 public

-- Definition (Pointed space)
record Pointed {ℓ} : Type (lsuc ℓ) where
  field 
    space : Type ℓ
    point : space
open Pointed public

-- Definition (Adjoining a disjoint basepoint)
data _₊ {ℓ} (X : Type ℓ) : Type ℓ where
  inSpace : X -> X ₊
  pt : X ₊

-- The following 3 definitions follow the style of the HoTT book:
-- Definition 1.1.8 (Cone of a space)
data Cone {ℓ} (X : Type ℓ) : Type ℓ where
  vertex : Cone X
  base : X -> Cone X
  generatrix : (x : X) -> Path (Cone X) (base x) vertex

-- Definition 1.1.10 (Suspension of a space)
data Susp {ℓ} (X : Type ℓ) : Type ℓ where
  north : Susp X
  south : Susp X
  mer : (x : X) -> Path (Susp X) north south

-- Example 1.1.12 (Functoriality of suspensions)
suspIsFunctorial : {ℓ : Level} -> Functor {ℓ} Susp
suspIsFunctorial = record
  { fmap = λ f -> λ
    { north -> north 
    ; south -> south
    ; (mer x i) -> mer (f x) i
    }
  ; funIdn = funExt (λ
    { north -> refl
    ; south -> refl
    ; (mer x i) -> refl
    })
  ; funComp = funExt (λ
    { north -> refl
    ; south -> refl
    ; (mer x i) -> refl
    })
  }

-- Definition 1.1.13 (Wedge sum)

-- Definition 1.1.15 (Smash product)

-- Definition (Sphere)
𝕊 : (n : ℕ) -> Pointed {lzero}
𝕊 zero    = record { space = Bool; point = false}
𝕊 (suc n) = record { space = Susp (space (𝕊 n)); point = north }

-- NOTE: While this is general, it is rather ugly to work with this definition, thus, for convenience:
-- Definition (Circle)
data 𝕊¹ : Type where
  baseₛ₁ : 𝕊¹
  loopₛ₁ : baseₛ₁ ≡ baseₛ₁

𝕊¹ₚ : Pointed
𝕊¹ₚ = record { space = 𝕊¹; point = baseₛ₁ }

-- NOTE: This is just a nice repackage of Susp for what is to come
Σₚ : {ℓ : Level} (X : Pointed {ℓ}) -> Pointed {ℓ}
Σₚ X = record { space = Susp (space X); point = north }

-- Definition (Pointed Map)
record Map {ℓ} (X Y : Pointed {ℓ}) : Type ℓ where
  field
    map : space X -> space Y
    ptCoe : Path (space Y) (map (point X)) (point Y)

-- Definition (Loop Space)
-- NOTE: This follows CHT's definition
Ω :  (X : Pointed) -> Pointed
Ω X = record { space = Map 𝕊¹ₚ X; point = record { map = λ s -> point X; ptCoe = refl } }
    
-- Proposition (Loop-Suspension Adjunction)
loopSuspAdjunction : {X Y : Pointed} -> Map (Σₚ X) Y ≡ Map X (Ω Y)
loopSuspAdjunction = isoToPath (iso loopSuspCurry {!!} {!!} {!!})
  where loopSuspCurry : {X Y : Pointed} -> Map (Σₚ X) Y -> Map X (Ω Y)
        loopSuspCurry = λ (record { map = f; ptCoe = h }) -> record
          { map = λ x -> record
            { map = λ
              { baseₛ₁ -> f north
              ; (loopₛ₁ i) -> f (mer x i)
              }
            ; ptCoe = h
            }
          ; ptCoe = {!!}
          }

-- Definition (Weak Equivalence)
record _≅_ {ℓ} (X Y : Type ℓ) : Type (lsuc ℓ) where
  field
    weakequiv : {K : Type ℓ} -> (K -> X) ≡ (K -> Y)
